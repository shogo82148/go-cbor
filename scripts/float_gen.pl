#!/bin/env perl

use v5.38;
use utf8;
use strict;
use FindBin;
no warnings "experimental::for_list";

sub byteSlice($hex) {
    my @ret;
    for my ($a, $b) (split //, $hex) {
        push @ret, "0x$a$b";
    }
    my $slice = join ", ", @ret;
    return "[]byte{$slice}";
}

print <<EOF;
// Code generated by scripts/float_gen.pl; DO NOT EDIT.

package cbor

var f64ToBytesTests = []struct {
    f64 uint64
    bytes []byte
}{
EOF

# f64_to_f32.txt is generated by TestFloat-3b/testfloat_gen.
# http://www.jhauser.us/arithmetic/TestFloat.html
# $ ./testfloat_gen f64_to_f32 > f64_to_f32.txt
open my $fh1, "<", "$FindBin::Bin/f64_to_f32.txt" or die "Can't open f64_to_f32.txt: $!";

# f64_to_f16.txt is generated by TestFloat-3b/testfloat_gen.
# http://www.jhauser.us/arithmetic/TestFloat.html
# $ ./testfloat_gen f64_to_f16 > f64_to_f16.txt
open my $fh2, "<", "$FindBin::Bin/f64_to_f16.txt" or die "Can't open f64_to_f16.txt: $!";

while(1) {
    my $line1 = <$fh1>;
    my $line2 = <$fh2>;
    last unless defined $line1 && defined $line2;

    my ($f64_1, $f32, $flag32) = split /\s+/, $line1;
    my ($f64_2, $f16, $flag16) = split /\s+/, $line2;
    if ($f64_1 ne $f64_2) {
        die "inputs are not match: $f64_1 ne $f64_2. you generate data with same seed";
    }

    if ($flag16 eq "00") {
        # converting to f16 is lossless; we can use f16.
        printf("{ 0x%s, %s },\n", $f64_1, byteSlice($f16));
    } elsif ($flag32 eq "00") {
        # converting to f32 is lossless; we can use f32.
        printf("{ 0x%s, %s },\n", $f64_1, byteSlice($f32));
    } else {
        # converting to f32 and/or f16 is lossy; we use f64.
        printf("{ 0x%s, %s },\n", $f64_1, byteSlice($f64_1));
    }
}

say "}";

close $fh1;
close $fh2;
